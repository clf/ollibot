%{ == Language definition == }%

%{ === Expressions === }%

num : type.            % Integers (finite domain)
exp : type.            % Expressions (syntax trees)
tm  : type.            % Terms (apply tags here...)
var : type.            % Variables (abstract)
tag : type.            % Tags (abstract)

t : tag -> tm -> exp.

v : var -> exp.
lam :  (var -> exp) -> exp.
n : num -> exp.
app : exp -> exp -> exp.


%{ === Frames === }%


frame : type.                    % Frames (syntax trees)

fapp1 : exp -> exp -> frame.    % fapp1(D1,E2) - wait on lambda @ D1
fapp2 : exp -> exp -> frame.    % fapp2(FP,D2) - wait on value @ D2
fdest : exp -> frame.            % fdest(D)     - wait on value @ D


%{ == Dynamic semantics == }%

eval   : exp   -> exp -> %( lin+ )% %[ pers+ ]% .
comp   : frame -> exp -> %( lin+ )% %[ pers+ ]% .
return : exp   -> exp -> %( lin+ )% %[ pers+ ]% .

vreturn : exp -> var -> pers+. 

%[ sk_var : (var -> exp) -> var. ]%


%{ === Eager evaluation === }%

eval(v X, Dest), vreturn(Val, X) -> return(Val, Dest).
eval(lam (λx. E x), Dest) -> return(lam (λx. E x), Dest).
eval(n N, Dest) -> return (n N, Dest).

eval(app E1 E2, Dest)
-------------------> ∃d1. 
comp(fapp1 d1 E2, Dest),
eval(E1, d1)
%[, d1 == E1 ]%.

comp(fapp1 Dest1 E2, Dest),
return(V, Dest1)
-------------------> ∃d2.
comp(fapp2 V d2, Dest),
eval(E2, d2) 
%[, d2 == E2 ]%.

comp(fapp2 (lam \x. E x) Dest2, Dest),
return(V, Dest2)
-------------------> ∃x. ∃d0.
comp(fdest d0, Dest),
eval(E x, d0),
vreturn(V, x)
%[, x == sk_var E, d0 == lam \x. E x ]% .

last:
comp(fdest Dest0, Dest),
return(V, Dest0)
------------------->
return(V, Dest).
