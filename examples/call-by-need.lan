%{ Specification/approximation of a language with a call-by-need semantics.
In a call-by-need language, a function argument is evaluated at most once,
but it is only evaluated at such time as evaluation actually requires the value
of the variable. }%

%{ == Language definition == }%

%{ === Expressions === }%

num : type.            % Integers (finite domain)
exp : type.            % Expressions (syntax trees)
var : type.            % Variables (abstract)

v : var → exp.
lam : (var → exp) → exp.
n : num → exp.
app : exp → exp → exp.


%{ === Values === }%

value : type.

nv : num → value.

fn_ptr : type.         % Function pointers (abstract)
fv : fn_ptr → value.

%{ Rather than passing around functions themselves as values, we instead
pass around immutable "function pointers," storing the expressions themselves
in a functions relation. }%

functions : fn_ptr → (var → exp) → pers+.


%{ === Frames === }%

dest : type.           % Destinations (abstract)
frame : type.          % Frames (syntax trees)

fapp1 : dest → exp → frame.    % fapp1(D1,E2) - wait on lambda @ D1
fdest : dest → frame.          % fdest(D)     - wait on value @ D


%{ == Dynamic semantics == }%

%{
Three propositions are rather common to the specification of functional
languages:

* <tt>eval</tt> is an eager proposition that traces out the structure of a term that will eventually be evaluated to a destination. 
* <tt>comp</tt> is an delaying proposition that waits for computation to be delivered so that it can be returned to a destination.
* <tt>return</tt> is a passive proposition that passes a value back to a destination.
}%

eval   : exp   → dest → %( lin+ )% %[ pers+ ]% .
comp   : frame → dest → %( lin+ )% %[ pers+ ]% .
return : value → dest → %( lin+ )% %[ pers+ ]% .

%{ 
We actually need a "variable" version of each of these three for the 

* <tt>veval</tt> is not actually eager as the name suggests - if it was eager, then the language would collapse to speculative parallelism. Instead, <tt>veval</tt> suspends an expression until it is needed to evaluate a variable.
* <tt>vcomp</tt> is like <tt>comp</tt>, but it waits for a computation so that a value can be returned to a variable, not a destination.
* <tt>vreturn</tt> is like <tt>return</tt>, but it passes a value back to a variable, not a destiantion. This predicate therefore must be persistent because, unless the underlying language is linear, variables may need to have values passed to them at multiple occurrences.

}%

vreturn : value → var → pers+. 
veval : exp -> var -> pers+.
vcomp : frame -> var -> pers+.

%{ === Eager evaluation === }%

eval(v X, Dest),
vreturn(Val, X)
------------------->
return(Val, Dest).

%{ I don't believe another choice of skolem constant here would make too much
of a difference. }%

sk_var : var -> dest.
sk_dest : dest -> fn_ptr.
sk_fun : dest -> dest.
sk_fn_body : fn_ptr -> dest.
sk_fn_var : fn_ptr -> var.

eval(v X, Dest),
veval(E, X)
-------------------> Exists d.
vcomp(fdest(d), X),
eval(E, d)
%[, (d == sk_var(X)) ]% . 

eval(lam(\x. E x), Dest)
-------------------> ∃fp.
functions(fp, \x. E x),
return(fv(fp), Dest)
%[, fp == sk_dest(Dest) ]% .

eval(n N, Dest)
------------------->
return(nv(N), Dest).

eval(app(E1,E2), Dest)
-------------------> ∃d1. 
comp(fapp1(d1,E2), Dest),
eval(E1, d1)
%[, d1 == sk_fun(Dest) ]% .


%{ === Delayed evaluation === }%

%{ This analysis brings out the possibility of distinguishing the call site
of an x by using Dest instead of FP in the sk_fn_var. Would this be 1-CFA? }%

comp(fapp1(Dest1,E2), Dest),
return(fv(FP), Dest1),
functions(FP, \x. E x)
-------------------> ∃x. ∃d0.
eval(E x, d0),
veval(E2, x),
comp(fdest(d0), Dest)
%[, d0 == sk_fn_body(FP), x == sk_fn_var(FP) ]% .

comp(fdest(Dest0), Dest),
return(Val, Dest0)
------------------->
return(Val, Dest).

last:
vcomp(fdest(Dest2), X),
return(Val, Dest2)
------------------->
vreturn(Val, X). 
