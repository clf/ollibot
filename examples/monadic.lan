%{ Specification/approximation of a monadic language with assignments. 

Interesting assumptions:
* Lists are built in. }%

%{ == Language definition == }%

%{ === Objects === }%
ty : type.    % Type labels (finite domain)
field : type. % Field labels (finite domain)

%{ A type is associated with a finite list of fields using the fields 
relation }%
list : type.
nil : list.
cons : field -> list -> list.

fields : ty → list → pers+. 


%{ === Tagged data === }%
data : type.  

loc : type.   % Memory locations (abstract)
l : loc → data.

num : type.   % Integers (finite domain)
n : num → data.

null : data.  % Uninitalized data

%{ === Expressions === }%
var : type.   % Variables (abstract)
exp : type.   % Expressions (syntax trees)
func : type.  % Function labels (finite domain)

new : ty, (var → exp) → exp.           % x   := new T
set : (var, var, exp) → exp.            % x   := y
setcon : (var, data, exp) → exp.        % x   := c
setfld : (var, var, field, exp) → exp.  % x   := y.f
fldset : (var, field, var, exp) → exp.  % x.f := y 
ret : exp.

%{ A function label is associated with a monadic expression with a free
variable using the funcs relation. }%
funcs : func → (var → exp) → pers+.   % fun f = x.e
call : func -> var -> exp -> exp.       % f(x)


%{ == Dynamic semantics == }%
dest : type.  % Destinations (abstract)

eval : exp → dest → %( lin+ )% %[ pers+ ]% .
return : dest -> %( lin+ )% %[ pers+ ]% .

pts : var → data → %( lin+ )% %[ pers+ ]% .
hpts : loc → field → data → %( lin+ )% %[ pers+ ]% .
newfields : loc → list → %( lin+ )% %[ pers+ ]% .
wait : dest → exp → dest → %( lin+ )% %[ pers+ ]% .

%[
sk_y : (var -> exp) -> dest -> var.
sk_l : (var -> exp) -> dest -> loc.
]%

%{ === Object creation === }%

eval(new(Ty,\lambda x. M x), Dest), 
fields(Ty,Fields)
-------------------> ∃y. ∃loc. 
pts(y, l loc), 
eval(M y, Dest), 
newfields(loc, Fields)
%[, y = sk_y(M,Dest), l = sk_l(M,Dest) ]% .

true : pers+. true.
newfields(L,nil) → (true).

newfields(L, cons(F, Fields))
------------------->
newfields(L,Fields), 
hpts(L,F,null).


%{ === Pointer update === }%

eval(set(X,Y,M), Dest),
pts(X, ValX),
pts(Y, ValY)
------------------->
eval(M, Dest),
pts(X, ValY)
%(, pts(Y, ValY) )%.                     % Re-assertion unnecessary in approx.

eval(setcon(X,Val,M), Dest),
pts(X, ValX)
------------------->
eval(M, Dest),
pts(X, Val).

eval(setfld(X,Y,F,M), Dest),
%( pts(X, ValX), )%                      % Invariant in approximation
pts(Y, l L),
hpts(L, F, ValF)
------------------->
eval(M, Dest),
pts(X, ValF),
%( pts(Y, l L), hpts(L, F, ValF) )% . % Re-assertion unnecessary in approx.

eval(fldset(X,F,Y,M), Dest),
pts(X, l L),
pts(Y, ValY),
%( hpts(L, F, ValF) )%                   % Invariant in approximation
------------------->
eval(M, Dest),
%( pts(X, l L), pts(Y, ValY), )%       % Re-assertion unnecessary in approx.
hpts(L, F, ValY).


%{ === Function call/return === }%

eval(call(Proc, Y, M), Dest),
pts(Y, ValY),
funcs(Proc, \lambda z. MBody z)
-------------------> ∃z. ∃dest. 
eval(MBody z, dest),
pts(z, ValY),
wait(dest, M, Dest)
%[, z = sko_param(Proc), dest = sko_fun(p) ]% .


wait(Dest', M, Dest),
return(Dest')
------------------->
eval(M, Dest).

eval(ret, Dest)
------------------->
return(Dest).

