%{ Specification/approximation of a language with a call-by-value semantics.
Ends up behaving much like the speculative parallelsim approximation, but it is
slightly more precise. 

We could achieve pretty much the same approximation described here by having a 
parallel evaluation of both the function and the argument of an application. }%

%{ == Language definition == }%

%{ === Expressions === }%

num : type.            % Integers (finite domain)
exp : type.            % Expressions (syntax trees)
var : type.            % Variables (abstract)

v : var → exp.
lam : (var → exp) → exp.
n : num → exp.
app : exp → exp → exp.


%{ === Values === }%

value : type.

nv : num → value.

fn_ptr : type.         % Function pointers (abstract)
fv : fn_ptr → value.

%{ Rather than passing around functions themselves as values, we instead
pass around immutable "function pointers," storing the expressions themselves
in a functions relation. }%

functions : fn_ptr → (var → exp) → pers+.


%{ === Frames === }%

dest : type.           % Destinations (abstract)
frame : type.          % Frames (syntax trees)

fapp1 : dest → exp → frame.    % fapp1(D1,E2) - wait on lambda @ D1
fapp2 : fn_ptr → dest → frame. % fapp2(FP,D2) - wait on value @ D2
fdest : dest → frame.          % fdest(D)     - wait on value @ D


%{ == Dynamic semantics == }%

%{
Three propositions are rather common to the specification of functional
languages:

* <tt>eval</tt> is an eager proposition that traces out the structure of a term that will eventually be evaluated to a destination. 
* <tt>comp</tt> is an delaying proposition that waits for computation to be delivered so that it can be returned to a destination.
* <tt>return</tt> is a passive proposition that passes a value back to a destination.
}%

eval   : exp   → dest → %( lin+ )% %[ pers+ ]% .
comp   : frame → dest → %( lin+ )% %[ pers+ ]% .
return : value → dest → %( lin+ )% %[ pers+ ]% .

%{ 
We also use the function <tt>vreturn</tt> to pass the value of a variable to all instances of that variable.
}%

vreturn : value → var → pers+. 

%{ === Eager evaluation === }%

eval(v X, Dest),
vreturn(Val, X)             % Always immediately available in a CBV language
------------------->
return(Val, Dest).

%{ If we replaced Dest in the approximation's skolem constant with (\x E x),
the only other apparent option, we would equate all syntatically identical
functions instead of all functions from the same position in the program,
which is actually less precise than a typical 0-CFA analysis. }% 

eval(lam(\lambda x. E x), Dest)
-------------------> ∃fp.
functions(fp, \lambda x. E x),
return(fv(fp), Dest)
%[, fp = sk_dest(Dest) ]% .

eval(n N, Dest)
------------------->
return(nv(N), Dest).

eval(app(E1,E2), Dest)
-------------------> ∃d1. 
comp(fapp1(d1,E2), Dest),
eval(E1, d1)
%[, d1 = sk_fun(Dest) ]% .


%{ === Delayed evaluation === }%

comp(fapp1(Dest1,E2), Dest),
return(fv(FP), Dest1)
-------------------> ∃d2.
eval(E2, d2),
comp(fapp2(FP, d2), Dest)
%[, d2 = sk_arg(Dest) ]% .

comp(fapp2(FP, Dest2), Dest),
return(Val, Dest2),
functions(FP, \lambda x. E x)
-------------------> ∃x. ∃d0.
eval(E x, d0),
comp(fdest(d0), Dest),
vreturn(Val, x)
%[, d2 = sk_fn_body(FP), x = sk_fn_var(FP) ]% .

comp(fdest(Dest0), Dest),
return(Val, Dest0)
------------------->
return(Val, Dest).


