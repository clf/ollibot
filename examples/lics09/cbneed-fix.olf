

elam : eval(lam λx. E x) ->> return(lam E).
eapp₁ : eval(app E₁ E₂) ->> comp(app₁ E₂) • eval(E₁).
eapp₂ : comp(app₁ E₂) • return(V₁) ->> comp(app₂ V₁) • eval(E₂).
eapp₃ : comp(app₂ (lam λx.E₀ x)) • return(V₂) ->> eval(E₀ V₂).

efix  : eval(fix λx. E x) ->> ∃D. eval(E D) • ¡susp (E D) D.
esusp : eval(D) • ¡susp E D ->> comp(bind₁ D) • eval E.
ebind : comp(bind₁ D) • return(V) ->> return(V) • !bind V D.
evar  : eval(D) • !bind V D ->> return V.

%% This is `fix(x.x)`, which you can't write in ML, but which falls into the
%% limited set of expressions that can be detected by "black holes."

%trace * eval(fix λx. x).

%% This is `fix(f.λx.f x)`, which you can write in ML as `fun f x = f x`.

%trace 18 eval(app (fix λf. lam λx. app f x) (lam λz.z)).